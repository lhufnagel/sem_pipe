c-----------------------------------------------------------------------
c     Turbulent pipe flow 
c     Along (positive) z-direction
c     
c     Map the generated velocity fields to a coarser mesh to do POD
c
c     Lorenz Hufnagel, hufnagel@kth.se
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userq  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV,NID
      include 'TSTEP_DEF'
      include 'TSTEP' ! ISTEP,IOSTEP
      include 'MASS_DEF'
      include 'MASS'  ! nelgt
      include 'SOLN_DEF'      
      include 'SOLN'  ! V[XYZ],V[XYZ]P
      include 'PARALLEL_DEF'
      include 'PARALLEL'  ! nelgt

      character*132  newfld, oldfld, new_geometry
      logical file_exists
      character*80 tmp_string
      integer counter


      oldfld = 'maspod0.f00001'
      inquire(file=oldfld,exist=file_exists); 

      if (.not.file_exists) then 
c     Output mass matrix (in vx field) at same dt.
c     NOTE: mass matrix OF NEW GEOMETRY, i.e. at first run
        call outpost(bm1,vy,vz,pr,t,'mas')
      endif

      call nekgsync()

      new_geometry = 'new_geom.f00000'
      inquire(file=new_geometry,exist=file_exists); 

      if (.not.file_exists) then
        if (nid.eq.0) then
        write(*,*) 
     $  'You are probably running with the new mesh in pod.rea'
        write(*,*) 
     $  'To genereate new_geom.f00000, simply rename pod0.f00001'
        endif
        return
      endif

      counter = 1
      write(tmp_string,'(i5.5)') counter
      newfld = './pipe_coarse0.f'//adjustl(trim(tmp_string))
      inquire(file=oldfld,exist=file_exists); 

      do while (file_exists)

        counter = counter + 1
        write(tmp_string,'(i5.5)') counter
        newfld = './pipe_coarse0.f'//adjustl(trim(tmp_string))
        inquire(file=newfld,exist=file_exists); 

      end do

      if (counter.gt.1.and.nid.eq.0) write(*,*) 
     $  'Found existing interpolated fields up to ', newfld

      oldfld = '../pipe0.f'//adjustl(trim(tmp_string))
      inquire(file=oldfld,exist=file_exists); 

      do while (file_exists)
        call g2gi(newfld, oldfld, new_geometry) ! grid2grid interpolation  

        counter = counter + 1
        write(tmp_string,'(i5.5)') counter
        oldfld = '../pipe0.f'//adjustl(trim(tmp_string))
        newfld = './pipe_coarse0.f'//adjustl(trim(tmp_string))

        inquire(file=oldfld,exist=file_exists); 

      end do

      if (nid.eq.0) write(*,*) 
     $  'The end.'

      call exitt() 
      end

c-----------------------------------------------------------------------

      subroutine userbc (ix,iy,iz,iside,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine useric (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat
        implicit none
      call uprm_read
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat2
        implicit none
      include 'SIZE_DEF'
      include 'SIZE' ! nelv
      include 'GEOM_DEF'
      include 'GEOM' 
      include 'NEKUSE_DEF'
      include 'NEKUSE' ! XM1
      include 'INPUT_DEF'
      include 'INPUT' 
      include 'USERPAR' 

      integer i
      real angle, circumf

      if (abs(bent_phi).gt.1e-10) then

c     Bend and translate the straight pipe
c     The sweep of the bent arc is bent_phi
c     The pipe inlet is moved at (0,r1,0) so that the center of the bend
c     is in (0,0,0)

      circumf = bent_radius*bent_phi
c
      do i=1,nx1*ny1*nz1*nelv
        zm1(i,1,1,1) = zm1(i,1,1,1) + z_offset
        xm1(i,1,1,1) = xm1(i,1,1,1) + bent_radius

        if (zm1(i,1,1,1).gt.0.and.zm1(i,1,1,1).le.circumf) then
          angle=zm1(i,1,1,1)/bent_radius
          zm1(i,1,1,1) = xm1(i,1,1,1)*sin(angle)
          xm1(i,1,1,1) = xm1(i,1,1,1)*cos(angle)
        elseif (zm1(i,1,1,1).gt.circumf) then

          angle = zm1(i,1,1,1) - circumf

          zm1(i,1,1,1) = xm1(i,1,1,1)*sin(bent_phi)
     $    + angle*cos(bent_phi)
          xm1(i,1,1,1) = xm1(i,1,1,1)*cos(bent_phi) 
     $    - angle*sin(bent_phi)
        endif
      enddo
      param(59) = 1. ! 1 = deformed mesh

      endif
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat3
        implicit none
      return
      end

c------------------------------------------------------------------------
