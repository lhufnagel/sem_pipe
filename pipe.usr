c-----------------------------------------------------------------------
c     Turbulent pipe flow 
c     Along (positive) x-direction
c     
c     Turbulence at inlet is "generated" with synthetic eddy method 
c     JARRIN, Nicolas, et al. A synthetic-eddy-method for
c     generating inflow conditions for large-eddy simulations. International
c     Journal of Heat and Fluid Flow, 2006, 27. Jg., Nr. 4, S. 585-593.
c
c     Lorenz Hufnagel, hufnagel@kth.se
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userq  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV,NID
      include 'TSTEP_DEF'
      include 'TSTEP' ! ISTEP,IOSTEP
      include 'SOLN_DEF'      
      include 'SOLN'  ! V[XYZ],V[XYZ]P

      real, external :: dnekclock ! defined in math.f

      real rtime, tic
      save rtime
      data rtime  /0./

      ! SEM

      tic=dnekclock()
      call synthetic_eddies
      rtime = rtime + (dnekclock()-tic)

      if(istep.eq.nsteps.and.nid.eq.0) 
     $  write(6,'(A,e15.4)') 'synth. eddy method time = ', rtime

      ! Compute lambda_2 (stored in temperature field)
      if (mod(ISTEP,IOSTEP).eq.0.and. istep.gt.0) then
         if (NID.eq.0) write(6,*) ISTEP,IOSTEP,TIME,' compute lambda2'
         call lambda2(t(1,1,1,1,1))
      endif

      ! Statistics. Start recording at least 
      ! after initial synthetic eddies have left pipe
      ! (L/umean)/dt plus tolerance for smaller dt

      ! 4800 steps = 2x flow-throughs 
      if(istep.ge.1) call avg_stat_all

      ! Restart, NOT TESTED
      ! call checkpoint

c     CALL OPDIV (BDIVV,VX,VY,VZ)
c     CALL COL2 (BDIVV,BM2INV,NX2*NY2*NZ2*NELV)
c     call mappr(divv,bdivv,work1,work2)
c     call outpost2(vx,vy,vz,pr,bdivv,ldimt,'div')


      end

c-----------------------------------------------------------------------

      subroutine userbc (ix,iy,iz,iside,ieg)
c     NOTE ::: This subroutine MAY NOT be called by every process
        use SEM, only: u_sem, v_sem, w_sem, bulk_vel_diff

      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV
      include 'PARALLEL_DEF'
      include 'PARALLEL'  ! GLLEL
      include 'INPUT_DEF'
      include 'INPUT'  ! IF3D
      include 'NEKUSE_DEF'
      include 'NEKUSE'! U[XYZ],PA,TEMP,CBU

      integer, intent(in) :: ix,iy,iz,iside,ieg
      integer iel

c     SEM inflow

      iel=gllel(ieg)
      ux=u_sem(ix,iy,iz,iel) 
      uy=v_sem(ix,iy,iz,iel) 
      uz=w_sem(ix,iy,iz,iel) + bulk_vel_diff
         
      temp = 0.0d0

      end

c-----------------------------------------------------------------------

      subroutine useric (ix,iy,iz,ieg)

      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV
      include 'NEKUSE_DEF'
      include 'NEKUSE'! U[XYZ], [XYZ]

      integer, intent(in) :: ix,iy,iz,ieg

      real vel, tke, dissip, radius

      radius = sqrt(x**2. + y**2.)
      call SEMinputData(radius, vel, tke, dissip )

c     Simply prescribe mean inflow profile used by SEM as IC
      Ux = 0.
      Uy = 0.
      Uz = vel

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat
      use SEM, only: xbmin, xbmax, ybmin, ybmax, zbmin, zbmax, Vb,
     &   bbox_max, sigma_max, z_inlet
      implicit none
      real, external :: glmin, glmax ! defined in math.f

      include 'SIZE_DEF'
      include 'SIZE' ! nelv
      include 'INPUT_DEF' 
      include 'INPUT' ! [xyz]c

      real, parameter :: pi = 3.14159265358979323846264338327950288
      real ymin, ymax, xmin, xmax
      integer n

!     to read user module parameters
      call uprm_read

c     Initialize SEM variables
      n = 8*nelv

      ymin = glmin(yc,n)
      ymax = glmax(yc,n)
      xmin = glmin(xc,n)
      xmax = glmax(xc,n)
      z_inlet  = glmin(zc,n)
      
      ! The bounding "box" (more precisely a cylinder for the pipe)
      ! is just large enough to contain the compact support of all
      ! eddies. 
      xbmin = xmin - bbox_max
      xbmax = xmax + bbox_max
      ybmin = ymin - bbox_max
      ybmax = ymax + bbox_max
      zbmin = z_inlet - .5*sigma_max
      zbmax = z_inlet + .5*sigma_max
      Vb = (zbmax-zbmin)*ybmax**2.*pi
c     Vb = (xbmax-xbmin)*(ybmax-ybmin)*(zbmax-zbmin)

      if (nid.eq.0) write(*,*) 'Geom:',xbmin,xbmax,ybmin,ybmax,z_inlet

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat2
        implicit none
c     Initialize SEM, once GLL points are distributed
      call SEMinit
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat3
        implicit none
      return
      end

c------------------------------------------------------------------------
