c-----------------------------------------------------------------------
c     Turbulent pipe flow 
c     Along (positive) x-direction
c     
c     Turbulence at inlet is "generated" with synthetic eddy method 
c     JARRIN, Nicolas, et al. A synthetic-eddy-method for
c     generating inflow conditions for large-eddy simulations. International
c     Journal of Heat and Fluid Flow, 2006, 27. Jg., Nr. 4, S. 585-593.
c
c     Lorenz Hufnagel, hufnagel@kth.se
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userq  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV,NID
      include 'TSTEP_DEF'
      include 'TSTEP' ! ISTEP,IOSTEP
      include 'SOLN_DEF'      
      include 'SOLN'  ! V[XYZ],V[XYZ]P

      real, external :: dnekclock ! defined in math.f

      real rtime, tic
      save rtime
      data rtime  /0./

      ! SEM

      tic=dnekclock()
      call synthetic_eddies
      rtime = rtime + (dnekclock()-tic)

      if(istep.eq.nsteps.and.nid.eq.0) 
     $  write(6,'(A,e15.4)') 'synth. eddy method time = ', rtime

      ! Compute lambda_2 (stored in temperature field)
      if (mod(ISTEP,IOSTEP).eq.0.and. istep.gt.0) then
         if (NID.eq.0) write(6,*) ISTEP,IOSTEP,TIME,' compute lambda2'
         call lambda2(t(1,1,1,1,1))
      endif

      ! Statistics. Start recording at least 
      ! after initial synthetic eddies have left pipe
      ! (L/umean)/dt plus tolerance for smaller dt

      ! 4800 steps = 2x flow-throughs 
      if(istep.ge.1) call avg_stat_all

      ! Restart, NOT TESTED
      ! call checkpoint
      end

c-----------------------------------------------------------------------

      subroutine userbc (ix,iy,iz,iside,ieg)
c     NOTE ::: This subroutine MAY NOT be called by every process
        use SEM, only: u_sem, v_sem, w_sem, bulk_vel_diff

      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV
      include 'PARALLEL_DEF'
      include 'PARALLEL'  ! GLLEL
      include 'INPUT_DEF'
      include 'INPUT'  ! IF3D
      include 'NEKUSE_DEF'
      include 'NEKUSE'! U[XYZ],PA,TEMP,CBU

      integer, intent(in) :: ix,iy,iz,iside,ieg
      integer iel

c     SEM inflow

      iel=gllel(ieg)
      ux= u_sem(ix,iy,iz,iel) 
      uy= v_sem(ix,iy,iz,iel) 
      uz= w_sem(ix,iy,iz,iel) + bulk_vel_diff

      temp = 0.0d0

      end

c-----------------------------------------------------------------------

      subroutine useric (ix,iy,iz,ieg)
      use SEM, only: nElinlet, umean_inlet
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV
      include 'NEKUSE_DEF'
      include 'NEKUSE'! U[XYZ], [XYZ]
      include 'USERPAR' 

      integer, intent(in) :: ix,iy,iz,ieg

      integer ex
      real vel, tmp

c     Prescribe mean inflow profile used by SEM as IC
c     NOTE: The bending of the mean velocity does not look
c     perfectly plausible. Especially for stronger curvatures 
c     the velocity maximum seems focused towards the inner wall

      ex = mod(ieg-1,nElInlet)+1 

      vel = umean_inlet(ix,iy,ex)

      Uy = 0.
      Ux = 0.
      Uz = vel

      if (abs(bent_phi).gt.1e-10) then

        if (z.gt.0) then
          tmp = atan2(z,x)
          if (tmp.le.bent_phi) then
            Ux = -vel*sin(tmp)
            Uz = vel*cos(tmp)
          else
            Ux = -vel*sin(bent_phi) 
            Uz = vel*cos(bent_phi)
          endif
        elseif (z.le.0.and.x.lt.0) then
          Ux = -vel*sin(bent_phi) 
          Uz = vel*cos(bent_phi)
        endif
      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat
      use SEM, only: xbmin, xbmax, ybmin, ybmax, zbmin, zbmax, Vb,
     &   bbox_max, sigma_max, z_inlet
      implicit none
      real, external :: glmin, glmax ! defined in math.f

      include 'SIZE_DEF'
      include 'SIZE' ! nelv
      include 'INPUT_DEF' 
      include 'INPUT' ! [xyz]c
      include 'USERPAR' 

      real, parameter :: pi = 3.14159265358979323846264338327950288
      real ymin, ymax, xmin, xmax
      integer n

!     to read user module parameters
      call uprm_read

c     Initialize SEM variables
      n = 8*nelv

      ymin = glmin(yc,n)
      ymax = glmax(yc,n)
      xmin = glmin(xc,n)
      xmax = glmax(xc,n)
      z_inlet  = glmin(zc,n)

      if (abs(bent_phi).gt.1e-10) then
        z_inlet  =z_inlet + z_offset
      endif
      
      ! The bounding "box" (more precisely a cylinder for the pipe)
      ! is just large enough to contain the compact support of all
      ! eddies. 
      xbmin = xmin - bbox_max
      xbmax = xmax + bbox_max
      ybmin = ymin - bbox_max
      ybmax = ymax + bbox_max
      zbmin = z_inlet - .5*sigma_max
      zbmax = z_inlet + .5*sigma_max
      Vb = (zbmax-zbmin)*ybmax**2.*pi
c     Vb = (xbmax-xbmin)*(ybmax-ybmin)*(zbmax-zbmin)

      if (nid.eq.0) write(*,*)'SEM BBox',xbmin,xbmax,ybmin,ybmax,z_inlet

      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat2
        implicit none
      include 'SIZE_DEF'
      include 'SIZE' ! nelv
      include 'GEOM_DEF'
      include 'GEOM' 
      include 'NEKUSE_DEF'
      include 'NEKUSE' ! XM1
      include 'INPUT_DEF'
      include 'INPUT' 
      include 'USERPAR' 

      integer i
      real angle, circumf

c     Initialize SEM, once GLL points are distributed
      call SEMinit

      if (abs(bent_phi).gt.1e-10) then

c     Bend and translate the straight pipe
c     The sweep of the bent arc is bent_phi
c     The pipe inlet is moved at (0,r1,0) so that the center of the bend
c     is in (0,0,0)

        circumf = bent_radius*bent_phi
c
      do i=1,nx1*ny1*nz1*nelv
        zm1(i,1,1,1) = zm1(i,1,1,1) + z_offset
        xm1(i,1,1,1) = xm1(i,1,1,1) + bent_radius

        if (zm1(i,1,1,1).gt.0.and.zm1(i,1,1,1).le.circumf) then
          angle=zm1(i,1,1,1)/bent_radius
          zm1(i,1,1,1) = xm1(i,1,1,1)*sin(angle)
          xm1(i,1,1,1) = xm1(i,1,1,1)*cos(angle)
        elseif (zm1(i,1,1,1).gt.circumf) then

          angle = zm1(i,1,1,1) - circumf

          zm1(i,1,1,1) = xm1(i,1,1,1)*sin(bent_phi)
     $    + angle*cos(bent_phi)
          xm1(i,1,1,1) = xm1(i,1,1,1)*cos(bent_phi) 
     $    - angle*sin(bent_phi)
        endif
      enddo
      param(59) = 1. ! 1 = deformed mesh

      endif
        
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat3
        implicit none
      return
      end

c------------------------------------------------------------------------
