c-----------------------------------------------------------------------
c     Turbulent pipe flow 
c     Along (positive) x-direction
c     
c     Map the generated statistics from cartesian to polar mesh
c
c     Lorenz Hufnagel, hufnagel@kth.se
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userq  (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
        use AVG_read
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'  ! L[XYZ]1,LELV,NID
      include 'PARALLEL_DEF'
      include 'PARALLEL'  ! nelgt

      integer nf, i, j,n, m, ssf, ifld
      parameter (nf     = 62) ! Number of saved statistical fields 
      real, parameter :: twoPi = 6.283185307179586476925286766

      real, allocatable  :: stat_2D1(:,:)
      real, allocatable  ::  stat_2D(:,:)
      real, allocatable  :: stat_int(:,:)
      real, allocatable  ::   stat_R(:,:)

      real, allocatable  :: rg(:)
      real, allocatable  :: theta_g(:)


      integer CR
      integer ng_r, ng_theta

      real mRey, dtheta
      real mdomain_x, mdomain_y, mdomain_z
      real mtimes   , mtimee, mDT, matime
      real Ttimes   , Tatime      

      integer mnel
      integer polyx, polyy, polyz
      integer nstat, nrec , Tnrec 

      logical file_exists

      character*80 pippo
      character*80 inputname1, inputname2 
      character*80 hdr
      character*80 val1, val2, val3, val4, val5, val6
      character*80 val7, val8, val9, val10, val11,val12,val13

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

      real, allocatable :: pts(:,:)
      real, allocatable :: fieldout(:,:)
      real, allocatable :: dist(:), rst(:)
      integer, allocatable :: rcode(:), elid(:),proc(:)
c     common /hpts_r/ rst
c     common /hpts_i/ rcode,elid,proc

      integer icalld,npoints
      save    icalld,npoints
      data    icalld  /0/
      data    npoints /0/

      integer inth_hpts
      save    inth_hpts

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

      open(unit=20,form='unformatted',file='polar_mesh.bin')
      read(20) CR, ng_r, ng_theta
      allocate(rg(ng_r))
      allocate(theta_g(ng_theta))
      read(20) (rg(i),i=1,ng_r)
      close(20)

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C
      
      dtheta = twopi/ng_theta;
      do i = 1,ng_theta
          theta_g(i) = (i-1)*dtheta; 
      enddo

      open(unit=21,form='unformatted',file='theta_mesh.bin')
      write(21) CR, ng_r, ng_theta
      write(21) (theta_g(i),i=1,ng_theta)
      close(21)

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

      npoints= 0

      allocate(pts(ldim,ng_r*ng_theta))
      allocate(fieldout(nf,ng_r*ng_theta))
      allocate(dist(ng_r*ng_theta))
      allocate(rst(ng_r*ng_theta*ldim))
      allocate(rcode(ng_r*ng_theta))
      allocate(elid(ng_r*ng_theta))
      allocate(proc(ng_r*ng_theta))

      do i = 1,ng_theta
      do j = 1,ng_r
       npoints = npoints + 1
       pts(1,npoints) = rg(j)*cos(theta_g(i))
       pts(2,npoints) = rg(j)*sin(theta_g(i))
       !pts(3,npoints) = 1 ??
      enddo
      enddo

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C
  
       m=lx1*ly1*nelPerface

       allocate(stat_2D(m,nf))
       allocate(stat_2D1(m,nf))
       allocate(stat_int(m,nf))
       allocate(stat_R(m,nf))

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C


       do n = 1, nslices
       ssf = 1
       call rzero(stat_2d,lx1*ly1*nelperface*nf)
       call rzero(stat_2d1,lx1*ly1*nelperface*nf)
       Tatime = 0.
       Tnrec  = 0
       do while (.true.)

         write(pippo,'(F4.1, A, i4.4)') zslices(n), '_',  ssf
         inputname1 = 'recordings/stat_z_'//adjustl(trim(pippo))


         inquire(file=inputname1,exist=file_exists); 
         if (.NOT.file_exists) then
           if (ssf.eq.1) write(*,*) 
     $ '!!! WARNING: failed to find input slice for x=', zslices(n)
           goto 2908
         endif

         open(unit=33,form='unformatted',file=inputname1)

              read(33) hdr

              read(33) mRey,        ! Reynolds number
     &      mdomain_x, mdomain_y, mdomain_z,  ! domain size
     &      mnel,                             ! number of elements 
     &      polyx    , polyy    , polyz,      ! polynomial order
     &      nstat,                ! number of saved statistics 
     &      mtimes,           ! start time 
     &      mtimee,           ! end time
     &      matime,           ! averge time
     &      mDT,            ! time step
     &      nrec            ! number of time records

        Tatime = Tatime + matime
        Tnrec  = Tnrec  + nrec

        if(ssf.eq.1) then
          Ttimes = mtimes
        endif

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

        if (nstat.ne.nf) then
         write(6,*) 'Change nf to be equal to nstat'
         call exitt
        endif 


        if (nElperFace.ne.mnel) then
          write(6,*) 
     $  'change nElperFace in pipe.upar to be equal to that of the run'
         call exitt
        endif   


        if (nElperFace.ne.nelgt) then
          write(6,*) 
     $  'change nr. of elem in stats.rea to be equal to that of the run'
         call exitt
        endif   

        if (polyx.ne.lx1-1) then
         write(6,*) 'change lx1 to be equal to that of the run'
         call exitt
        endif   

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

        do ifld = 1,nstat
          read(33) (stat_R(j,ifld),j=1,m)
        enddo

        close(33) 
        write(*,*) inputname1

        do ifld=1,nstat
          do j=1,m
            stat_2D1(j,ifld) = stat_2D1(j,ifld) + 
     $         matime*stat_R(j,ifld)
          enddo
        enddo

        ssf = ssf + 1
      enddo

2908  continue

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      do ifld=1,nstat
        do j=1,m
          stat_2D(j,ifld) = stat_2D1(j,ifld)/Tatime
        enddo
      enddo

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

      write(pippo,'(F4.1)') zslices(n)
      inputname2 = 'recordings/polar_z_'//adjustl(trim(pippo))
      open(unit=37,form='unformatted',file=inputname2) 

      write(val1,'(1p,e17.9)') mRey  	   	        ! Reynolds number	  
      write(val2,'(1p,3e17.9)') mdomain_x,mdomain_y,mdomain_z ! domain size
      write(val3,'(i9)') mnel                                ! number of elements 
      write(val4,'(3i9)') polyx,polyy,polyz                   ! polynomial order
      write(val5,'(i9)')       nstat                         ! number of saved statistics 
      write(val6,'(1p,e17.9)') Ttimes                        ! start time
      write(val7,'(1p,e17.9)') mtimee                        ! end time
      write(val8,'(1p,e17.9)') Tatime                        ! average time
      write(val9,'(1p,e17.9)') mDT                           ! time step
      write(val10,'(i9)')      Tnrec                         ! number of time records
      write(val11,'(i9)')      ng_r                          ! 
      write(val12,'(i9)')      ng_theta                      ! 
      write(val13,'(i9)')      CR                            ! 


      write(37) '(Re ='//trim(val1)
     &   //') (Lx, Ly, Lz ='//trim(val2)
     &   //') (nel ='//trim(val3)
     &   //') (Polynomial order ='//trim(val4)
     &   //') (Nstat ='//trim(val5)
     &   //') (start time ='//trim(val6)
     &   //') (end time ='//trim(val7)
     &   //') (average time ='//trim(val8)
     &   //') (time step ='//trim(val9)
     &   //') (nrec ='//trim(val10)
     &   //') (nr ='//trim(val11)
     &   //') (nt ='//trim(val12)
     &   //') (CR ='//trim(val13)
     &   //')'

      write(37) mRey,
     &      mdomain_x, mdomain_y, mdomain_z,
     &      mnel,
     &      polyx    , polyy    , polyz,
     &      nstat,
     &      Ttimes,
     &      mtimee,
     &      Tatime,
     &      mDT,
     &      Tnrec,
     &      ng_r,
     &      ng_theta,
     &      CR

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

      if(icalld.eq.0) then
        if(nid.eq.0) write(6,*) 'found ', npoints, ' points'
        call intpts_setup(-1.0,inth_hpts) ! use default tolerance
      endif


      ! interpolate
      if(icalld.eq.0) then
          call findpts(inth_hpts,rcode,1,
     &                   proc,1,
     &                   elid,1,
     &                   rst,ndim,
     &                   dist,1,
     &                   pts(1,1),ndim,
     &                   pts(2,1),ndim,
     &                   pts(3,1),ndim,npoints)


          do i=1,npoints
             ! check return code 
             if(rcode(i).eq.1) then
               if(dist(i).gt.1e-12) then
                 write(6,'(A,4E15.7)') 
     &       ' WARNING: point on boundary or outside the mesh [x]yzd^2:'
     &       ,(pts(j,i),j=1,ndim),dist(i)
               endif   
             elseif(rcode(i).eq.2) then
               write(6,'(A,3E15.7)') 
     &          ' WARNING: point not within mesh [x]yz: !',
     &          (pts(j,i),j=1,ndim)
             endif
          enddo
          icalld = 1
       endif

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

      do ifld=1,nstat
        call findpts_eval(inth_hpts,fieldout(ifld,1),nstat,
     &                     rcode,1,
     &                     proc,1,
     &                     elid,1,
     &                     rst,ndim,npoints,
     &                     stat_2D(1,ifld))

        do i = 1,npoints     
          stat_int(i,ifld) = fieldout(ifld,i)
        enddo
     
        ! write interpolation results 
        if(nid.eq.0) then
            write(37) (stat_int(j,ifld),j=1,npoints)
        endif

      enddo
      close(37)
      write(*,*) inputname2


      enddo

C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C

        write(6,*)  'Fin'
      return

      end

c-----------------------------------------------------------------------

      subroutine userbc (ix,iy,iz,iside,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine useric (ix,iy,iz,ieg)
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat
        implicit none

!     to read user module parameters
        call uprm_read
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat2
        implicit none
      return
      end

c-----------------------------------------------------------------------

      subroutine usrdat3
        implicit none
      return
      end

c------------------------------------------------------------------------
